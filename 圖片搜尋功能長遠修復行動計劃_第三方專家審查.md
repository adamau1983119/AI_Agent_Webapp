# 圖片搜尋功能長遠修復行動計劃

**計劃制定日期：** 2026年1月7日  
**計劃目標：** 徹底解決圖片搜尋功能問題，建立穩定、可維護的長期架構  
**計劃期限：** 分階段實施，總計 4-6 週  
**審查對象：** 第三方專家

---

## 執行摘要

本計劃旨在徹底解決圖片搜尋功能問題，並建立一個穩定、可擴展、可維護的長期架構。計劃分為四個階段：緊急修復、架構統一、長期優化、監控與維護。

---

## 階段 1：緊急診斷與修復（第1週）

### 1.1 診斷階段（1-2天）

#### 任務 1.1.1：直接測試 Google Custom Search API
**目標：** 確認 Google API 配置是否正確

**執行步驟：**
1. 使用提供的測試腳本 `test_google_cse.sh` 直接測試 Google API
2. 測試多個查詢詞（cat, dog, sunset, technology）
3. 記錄所有 HTTP 狀態碼和響應內容

**驗證標準：**
- ✅ 所有測試查詢返回 HTTP 200
- ✅ 至少 80% 的查詢返回 items > 0
- ✅ 記錄完整的測試結果報告

**預期結果：**
- 如果成功 → 問題在後端代碼實現
- 如果失敗 → 問題在 Google API 配置

**負責人：** 後端開發人員  
**交付物：** Google API 測試報告

---

#### 任務 1.1.2：檢查後端日誌完整性
**目標：** 確認後端是否正確記錄服務調用

**執行步驟：**
1. 在前端發起圖片搜尋請求
2. 檢查 Railway 日誌中是否有 Google Custom Search 調用記錄
3. 檢查是否有 DuckDuckGo 調用記錄
4. 記錄所有相關日誌

**驗證標準：**
- ✅ 每個圖片搜尋請求都有 trace_id
- ✅ 記錄每個服務的嘗試順序
- ✅ 記錄每個服務的調用結果（成功/失敗/空結果）

**預期結果：**
- 如果沒有日誌 → 請求未到達這些服務
- 如果有日誌但失敗 → 可以根據錯誤訊息定位問題

**負責人：** 後端開發人員  
**交付物：** 日誌分析報告

---

#### 任務 1.1.3：檢查前端 source 類型定義
**目標：** 確認前端是否正確支援所有圖片來源

**執行步驟：**
1. 檢查 `frontend/src/types/index.ts` 中的 `ImageSource` 類型定義
2. 檢查 `frontend/src/components/features/ImageSearch.tsx` 中的來源選項
3. 確認「所有來源」選項的實現邏輯

**驗證標準：**
- ✅ `ImageSource` 類型包含所有後端支援的來源
- ✅ 前端下拉選單顯示所有可用來源
- ✅ 「所有來源」選項正確傳遞 `undefined` 給後端

**預期結果：**
- 如果類型缺失 → 需要更新類型定義
- 如果選項缺失 → 需要更新 UI 組件

**負責人：** 前端開發人員  
**交付物：** 前端代碼審查報告

---

### 1.2 緊急修復階段（2-3天）

#### 任務 1.2.1：實現 trace_id 追蹤機制
**目標：** 為每個請求添加唯一追蹤 ID，便於診斷問題

**實施內容：**
```python
# backend/app/api/v1/images.py
import uuid

@router.get("/search")
async def search_images(...):
    trace_id = str(uuid.uuid4())[:8]
    logger.info(f"[{trace_id}] 圖片搜尋請求: keywords={keywords}, source={source}")
    # 傳遞 trace_id 到服務層
    result = await image_service.search(..., trace_id=trace_id)
```

**驗證標準：**
- ✅ 每個請求都有唯一的 trace_id
- ✅ 所有日誌都包含 trace_id
- ✅ 前端錯誤訊息包含 trace_id，便於追蹤

**負責人：** 後端開發人員  
**交付物：** 更新的 API 端點代碼

---

#### 任務 1.2.2：實現分級錯誤模型
**目標：** 區分不同類型的錯誤，提供詳細的錯誤資訊

**實施內容：**
```python
# backend/app/services/images/exceptions.py
class ImageSearchError(Exception):
    def __init__(self, code: str, source: str, message: str):
        self.code = code  # SOURCE_UNAVAILABLE, RATE_LIMIT, INVALID_CONFIG, NO_RESULTS
        self.source = source
        self.message = message
        super().__init__(f"[{source}] {code}: {message}")
```

**錯誤類型定義：**
- `SOURCE_UNAVAILABLE`: 服務不可用（API Key 未設定）
- `RATE_LIMIT`: API 配額用盡
- `INVALID_CONFIG`: 配置錯誤（API Key 或 Search Engine ID 無效）
- `NO_RESULTS`: 查詢無結果（正常情況）
- `UPSTREAM_ERROR`: 上游服務錯誤（5xx）
- `HTTP_ERROR`: HTTP 錯誤（非 2xx）

**驗證標準：**
- ✅ 所有錯誤都使用統一的錯誤類型
- ✅ 錯誤訊息包含足夠的診斷資訊
- ✅ 前端可以根據錯誤類型顯示不同的提示

**負責人：** 後端開發人員  
**交付物：** 錯誤處理模組和更新的服務代碼

---

#### 任務 1.2.3：添加詳細的服務調用日誌
**目標：** 記錄每個服務的嘗試和結果，便於診斷問題

**實施內容：**
```python
# backend/app/services/images/image_service_manager.py
async def search_images(self, keywords: str, ..., trace_id: str):
    attempts = []
    for service_name, service, service_source in self.services:
        try:
            logger.info(f"[{trace_id}] 嘗試使用 {service_name} 搜尋圖片: keywords={keywords}")
            images = await service.search_images(keywords, page, limit)
            logger.info(f"[{trace_id}] {service_name} 搜尋成功: 找到 {len(images)} 張圖片")
            if images:
                return {
                    "source": service_source.value,
                    "items": images,
                    "attempts": attempts
                }
            attempts.append({
                "source": service_source.value,
                "status": "no_results",
                "count": 0
            })
        except ImageSearchError as e:
            logger.warning(f"[{trace_id}] {service_name} 搜尋失敗: {e.code} - {e.message}")
            attempts.append({
                "source": service_source.value,
                "status": "error",
                "code": e.code,
                "message": e.message
            })
        except Exception as e:
            logger.exception(f"[{trace_id}] {service_name} 發生異常")
            attempts.append({
                "source": service_source.value,
                "status": "exception",
                "message": str(e)
            })
    
    # 所有服務都失敗
    logger.warning(f"[{trace_id}] 所有圖片服務都失敗，返回空結果")
    return {
        "source": None,
        "items": [],
        "attempts": attempts
    }
```

**驗證標準：**
- ✅ 每個服務嘗試都有日誌記錄
- ✅ 記錄成功/失敗/空結果的詳細資訊
- ✅ 返回的響應包含 attempts 陣列

**負責人：** 後端開發人員  
**交付物：** 更新的服務管理器代碼

---

#### 任務 1.2.4：改進 Google Custom Search 服務實現
**目標：** 確保 Google Custom Search API 調用正確且可觀測

**實施內容：**
```python
# backend/app/services/images/google_custom_search.py
class GoogleCustomSearchService(ImageServiceBase):
    def __init__(self):
        self.api_key = getattr(settings, 'GOOGLE_API_KEY', '')
        self.search_engine_id = getattr(settings, 'GOOGLE_SEARCH_ENGINE_ID', '')
        
        # 初始化時驗證配置
        if not self.api_key or not self.search_engine_id:
            raise ImageSearchError(
                "INVALID_CONFIG",
                "google_custom_search",
                "GOOGLE_API_KEY 或 GOOGLE_SEARCH_ENGINE_ID 未設定"
            )
        
        self.base_url = "https://www.googleapis.com/customsearch/v1"
        logger.info("✅ Google Custom Search 服務已初始化")
    
    async def search_images(self, keywords: str, page: int = 1, limit: int = 20, trace_id: str = ""):
        limit = min(limit, 10)  # Google 限制每頁最多 10 張
        
        params = {
            "key": self.api_key,
            "cx": self.search_engine_id,
            "q": keywords,
            "searchType": "image",  # 關鍵：必須指定為圖片搜尋
            "num": limit,
            "start": (page - 1) * limit + 1,
            "safe": "active",
        }
        
        # 記錄請求（隱藏 API Key）
        logger.info(f"[{trace_id}] Google Custom Search 請求: q='{keywords}', num={limit}, start={params['start']}")
        
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(self.base_url, params=params)
                
                # 記錄響應狀態
                logger.info(f"[{trace_id}] Google Custom Search 響應: status={response.status_code}")
                
                # 處理不同狀態碼
                if response.status_code == 429:
                    raise ImageSearchError("RATE_LIMIT", "google_custom_search", "API 配額已用完")
                if response.status_code == 403:
                    raise ImageSearchError("INVALID_CONFIG_OR_PERMISSION", "google_custom_search", "API Key 無效或權限不足")
                if response.status_code >= 500:
                    raise ImageSearchError("UPSTREAM_ERROR", "google_custom_search", f"上游服務錯誤: {response.status_code}")
                if response.status_code != 200:
                    raise ImageSearchError("HTTP_ERROR", "google_custom_search", f"HTTP 錯誤: {response.status_code}")
                
                response.raise_for_status()
                data = response.json()
                
                # 記錄搜尋資訊
                search_info = data.get("searchInformation", {})
                total_results = search_info.get("totalResults", "0")
                logger.info(f"[{trace_id}] Google Custom Search 結果: totalResults={total_results}, items={len(data.get('items', []))}")
                
                items = data.get("items", [])
                
                # 過濾和轉換結果
                results = []
                for item in items:
                    link = item.get("link", "")
                    mime = item.get("mime", "")
                    
                    # 只保留圖片類型的結果
                    if not link:
                        continue
                    if mime and not mime.startswith("image/"):
                        continue
                    
                    results.append({
                        "id": f"google_{hash(link) % 1000000}",
                        "url": link,
                        "thumbnail_url": item.get("image", {}).get("thumbnailLink", link),
                        "width": item.get("image", {}).get("width", 0),
                        "height": item.get("image", {}).get("height", 0),
                        "title": item.get("title", ""),
                        "source": ImageSource.GOOGLE_CUSTOM_SEARCH.value,
                        "photographer": item.get("displayLink", ""),
                        "photographer_url": item.get("image", {}).get("contextLink", ""),
                        "license": "Unknown",
                        "keywords": [keywords],
                    })
                
                logger.info(f"[{trace_id}] Google Custom Search 成功: 返回 {len(results)} 張圖片")
                return results
                
        except ImageSearchError:
            raise
        except httpx.TimeoutException:
            raise ImageSearchError("UPSTREAM_ERROR", "google_custom_search", "請求超時")
        except Exception as e:
            logger.exception(f"[{trace_id}] Google Custom Search 發生異常")
            raise ImageSearchError("UPSTREAM_ERROR", "google_custom_search", f"未知錯誤: {str(e)}")
```

**驗證標準：**
- ✅ 初始化時驗證配置
- ✅ 記錄所有請求參數（隱藏敏感資訊）
- ✅ 記錄響應狀態和結果數量
- ✅ 正確處理所有錯誤情況
- ✅ 只返回圖片類型的結果

**負責人：** 後端開發人員  
**交付物：** 更新的 Google Custom Search 服務代碼

---

#### 任務 1.2.5：改進 API 響應格式
**目標：** 返回詳細的診斷資訊，避免統一返回空列表

**實施內容：**
```python
# backend/app/api/v1/images.py
@router.get("/search", response_model=ImageSearchResponse)
async def search_images(
    keywords: str = Query(..., description="搜尋關鍵字"),
    source: Optional[ImageSource] = Query(None, description="圖片來源（可選）"),
    page: int = Query(1, ge=1, description="頁碼"),
    limit: int = Query(20, ge=1, le=30, description="每頁數量")
):
    trace_id = str(uuid.uuid4())[:8]
    logger.info(f"[{trace_id}] 圖片搜尋請求: keywords={keywords}, source={source}, page={page}, limit={limit}")
    
    try:
        from app.services.images.image_service_manager import ImageServiceManager
        
        image_service = ImageServiceManager()
        
        # 搜尋圖片（返回包含 attempts 的結果）
        result = await image_service.search_images(
            keywords=keywords,
            source=source,
            page=page,
            limit=limit,
            trace_id=trace_id
        )
        
        # 轉換為回應格式
        image_responses = []
        for img in result.get("items", []):
            # ... 轉換邏輯 ...
            image_responses.append(ImageResponse(...))
        
        # 返回包含 attempts 的響應
        return ImageSearchResponse(
            data=image_responses,
            pagination=PaginationResponse.create(page, limit, len(image_responses)),
            attempts=result.get("attempts", []),  # 新增：嘗試記錄
            source=result.get("source")  # 新增：最終使用的來源
        )
        
    except ImageSearchError as e:
        logger.warning(f"[{trace_id}] 圖片搜尋錯誤: {e.code} - {e.message}")
        # 返回 200，但包含錯誤資訊
        return ImageSearchResponse(
            data=[],
            pagination=PaginationResponse.create(page, limit, 0),
            attempts=[{
                "source": e.source,
                "status": "error",
                "code": e.code,
                "message": e.message
            }],
            source=None
        )
    except Exception as e:
        logger.exception(f"[{trace_id}] 圖片搜尋發生未處理異常")
        # 僅在不可恢復的錯誤時返回 500
        return JSONResponse(
            status_code=500,
            content={
                "message": "伺服器內部錯誤",
                "trace_id": trace_id,
                "error": str(e) if settings.DEBUG else None
            }
        )
```

**驗證標準：**
- ✅ 響應包含 attempts 陣列
- ✅ 響應包含最終使用的來源
- ✅ 錯誤情況返回 200 而不是 500（除非不可恢復）
- ✅ 包含 trace_id 便於追蹤

**負責人：** 後端開發人員  
**交付物：** 更新的 API 端點代碼和 Schema

---

#### 任務 1.2.6：更新前端 ImageSource 類型定義
**目標：** 確保前端支援所有後端圖片來源

**實施內容：**
```typescript
// frontend/src/types/index.ts
export type ImageSource = 
  | 'unsplash'
  | 'pexels'
  | 'pixabay'
  | 'google_custom_search'  // 新增
  | 'duckduckgo'            // 新增

// frontend/src/components/features/ImageSearch.tsx
const imageSourceOptions = [
  { value: undefined, label: '所有來源' },
  { value: 'unsplash', label: 'Unsplash' },
  { value: 'pexels', label: 'Pexels' },
  { value: 'pixabay', label: 'Pixabay' },
  { value: 'google_custom_search', label: 'Google' },      // 新增
  { value: 'duckduckgo', label: 'DuckDuckGo' },            // 新增
]
```

**驗證標準：**
- ✅ 類型定義包含所有後端支援的來源
- ✅ 下拉選單顯示所有可用來源
- ✅ 「所有來源」選項正確傳遞 `undefined`

**負責人：** 前端開發人員  
**交付物：** 更新的類型定義和 UI 組件

---

#### 任務 1.2.7：改進前端錯誤顯示
**目標：** 顯示詳細的診斷資訊，幫助用戶理解問題

**實施內容：**
```typescript
// frontend/src/components/features/ImageSearch.tsx
const renderSearchResults = () => {
  if (isLoading) return <LoadingSpinner />
  
  if (error) {
    return (
      <ErrorDisplay 
        message="搜尋失敗"
        details={error.message}
        traceId={error.trace_id}
      />
    )
  }
  
  if (searchResults?.data?.length === 0) {
    // 顯示嘗試記錄
    const attempts = searchResults?.attempts || []
    return (
      <div>
        <EmptyState message="沒有找到圖片" />
        {attempts.length > 0 && (
          <div className="mt-4">
            <h4>搜尋嘗試記錄：</h4>
            <ul>
              {attempts.map((attempt, idx) => (
                <li key={idx}>
                  {attempt.source}: {attempt.status === 'no_results' 
                    ? '無結果' 
                    : attempt.status === 'error'
                    ? `錯誤 (${attempt.code}): ${attempt.message}`
                    : '異常'}
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    )
  }
  
  return <ImageGrid images={searchResults.data} />
}
```

**驗證標準：**
- ✅ 顯示 attempts 資訊
- ✅ 區分不同類型的錯誤
- ✅ 提供診斷資訊（trace_id）
- ✅ 用戶友好的錯誤訊息

**負責人：** 前端開發人員  
**交付物：** 更新的 UI 組件

---

### 1.3 驗證階段（1天）

#### 任務 1.3.1：端到端測試
**目標：** 驗證所有修復是否有效

**測試用例：**
1. **測試 1：手動搜尋 - 所有來源**
   - 操作：選擇「所有來源」，輸入關鍵字，點擊搜尋
   - 預期：返回圖片結果，日誌顯示嘗試了所有服務
   - 驗證：檢查後端日誌和前端顯示

2. **測試 2：手動搜尋 - Google Custom Search**
   - 操作：選擇「Google」，輸入關鍵字，點擊搜尋
   - 預期：返回 Google 圖片結果
   - 驗證：檢查後端日誌和前端顯示

3. **測試 3：手動搜尋 - DuckDuckGo**
   - 操作：選擇「DuckDuckGo」，輸入關鍵字，點擊搜尋
   - 預期：返回 DuckDuckGo 圖片結果
   - 驗證：檢查後端日誌和前端顯示

4. **測試 4：智能匹配照片**
   - 操作：點擊「智能匹配照片」
   - 預期：根據文章內容自動匹配圖片
   - 驗證：檢查後端日誌和圖片是否添加成功

5. **測試 5：錯誤情況處理**
   - 操作：使用無效的 API Key 測試
   - 預期：顯示詳細的錯誤訊息，包含 attempts 資訊
   - 驗證：檢查錯誤顯示是否正確

**驗證標準：**
- ✅ 所有測試用例通過
- ✅ 後端日誌完整記錄所有嘗試
- ✅ 前端正確顯示結果和錯誤資訊
- ✅ 沒有 500 錯誤（除非不可恢復的異常）

**負責人：** QA 測試人員  
**交付物：** 測試報告

---

## 階段 2：架構統一與優化（第2-3週）

### 2.1 統一服務類架構（第2週）

#### 任務 2.1.1：設計統一的圖片服務介面
**目標：** 定義統一的服務介面，消除兩個服務類的不一致

**實施內容：**
```python
# backend/app/services/images/base.py
from abc import ABC, abstractmethod
from typing import List, Dict, Any

class ImageProvider(ABC):
    """圖片服務提供者介面"""
    
    @property
    @abstractmethod
    def name(self) -> str:
        """服務名稱"""
        pass
    
    @property
    @abstractmethod
    def requires_api_key(self) -> bool:
        """是否需要 API Key"""
        pass
    
    @abstractmethod
    async def search_images(
        self,
        keywords: str,
        page: int = 1,
        limit: int = 20,
        trace_id: str = ""
    ) -> List[Dict[str, Any]]:
        """搜尋圖片"""
        pass
    
    @abstractmethod
    async def is_available(self) -> bool:
        """檢查服務是否可用"""
        pass

# 所有圖片服務都實現這個介面
class UnsplashService(ImageProvider):
    # 實現...
    
class PexelsService(ImageProvider):
    # 實現...
    
class GoogleCustomSearchService(ImageProvider):
    # 實現...
    
class DuckDuckGoService(ImageProvider):
    # 實現...
```

**驗證標準：**
- ✅ 所有服務都實現統一的介面
- ✅ 介面定義清晰明確
- ✅ 易於添加新的圖片服務

**負責人：** 後端架構師  
**交付物：** 統一的服務介面定義

---

#### 任務 2.1.2：實現統一的圖片服務管理器
**目標：** 統一 `ImageService` 和 `ImageServiceManager` 為一個服務類

**實施內容：**
```python
# backend/app/services/images/image_service.py
class ImageService:
    """統一的圖片服務管理器"""
    
    def __init__(self):
        # 初始化所有圖片服務提供者
        self.providers = [
            UnsplashService(),
            PexelsService(),
            PixabayService(),
            GoogleCustomSearchService(),
            DuckDuckGoService(),
        ]
        
        # 服務優先順序（可配置）
        self.priority_order = [
            "unsplash",
            "pexels",
            "pixabay",
            "google_custom_search",
            "duckduckgo",
        ]
        
        # 健康狀態快取
        self.health_cache = {}
    
    async def search_images(
        self,
        keywords: str,
        source: Optional[ImageSource] = None,
        page: int = 1,
        limit: int = 20,
        trace_id: str = ""
    ) -> Dict[str, Any]:
        """搜尋圖片（統一入口）"""
        attempts = []
        
        # 如果指定了來源，只使用該來源
        if source:
            provider = self._get_provider_by_source(source)
            if not provider:
                raise ImageSearchError(
                    "SOURCE_UNAVAILABLE",
                    source.value,
                    f"不支援的圖片來源: {source.value}"
                )
            
            return await self._try_provider(provider, keywords, page, limit, trace_id, attempts)
        
        # 否則按優先順序嘗試所有可用服務
        available_providers = self._get_available_providers()
        
        for provider in available_providers:
            result = await self._try_provider(provider, keywords, page, limit, trace_id, attempts)
            if result["items"]:
                return result
        
        # 所有服務都失敗
        return {
            "source": None,
            "items": [],
            "attempts": attempts
        }
    
    async def _try_provider(
        self,
        provider: ImageProvider,
        keywords: str,
        page: int,
        limit: int,
        trace_id: str,
        attempts: List[Dict]
    ) -> Dict[str, Any]:
        """嘗試使用單個提供者"""
        try:
            # 檢查服務是否可用
            if not await provider.is_available():
                attempts.append({
                    "source": provider.name,
                    "status": "unavailable",
                    "message": "服務不可用"
                })
                return {"source": None, "items": [], "attempts": attempts}
            
            # 搜尋圖片
            images = await provider.search_images(keywords, page, limit, trace_id)
            
            if images:
                logger.info(f"[{trace_id}] {provider.name} 搜尋成功: {len(images)} 張圖片")
                # 更新健康狀態
                self._update_health(provider.name, True)
                return {
                    "source": provider.name,
                    "items": images,
                    "attempts": attempts
                }
            else:
                attempts.append({
                    "source": provider.name,
                    "status": "no_results",
                    "count": 0
                })
                return {"source": None, "items": [], "attempts": attempts}
                
        except ImageSearchError as e:
            logger.warning(f"[{trace_id}] {provider.name} 搜尋失敗: {e.code} - {e.message}")
            # 更新健康狀態
            self._update_health(provider.name, False, e.code)
            attempts.append({
                "source": provider.name,
                "status": "error",
                "code": e.code,
                "message": e.message
            })
            return {"source": None, "items": [], "attempts": attempts}
        except Exception as e:
            logger.exception(f"[{trace_id}] {provider.name} 發生異常")
            self._update_health(provider.name, False, "EXCEPTION")
            attempts.append({
                "source": provider.name,
                "status": "exception",
                "message": str(e)
            })
            return {"source": None, "items": [], "attempts": attempts}
    
    def _get_available_providers(self) -> List[ImageProvider]:
        """獲取可用的服務提供者（根據健康狀態排序）"""
        providers = []
        for name in self.priority_order:
            provider = self._get_provider_by_name(name)
            if provider:
                providers.append(provider)
        # 根據健康狀態排序（健康的優先）
        providers.sort(key=lambda p: self._get_health_score(p.name), reverse=True)
        return providers
    
    def _update_health(self, provider_name: str, success: bool, error_code: str = None):
        """更新服務健康狀態"""
        if provider_name not in self.health_cache:
            self.health_cache[provider_name] = {
                "success_count": 0,
                "failure_count": 0,
                "last_success": None,
                "last_failure": None,
                "error_codes": {}
            }
        
        cache = self.health_cache[provider_name]
        if success:
            cache["success_count"] += 1
            cache["last_success"] = datetime.utcnow()
        else:
            cache["failure_count"] += 1
            cache["last_failure"] = datetime.utcnow()
            if error_code:
                cache["error_codes"][error_code] = cache["error_codes"].get(error_code, 0) + 1
    
    def _get_health_score(self, provider_name: str) -> float:
        """計算服務健康分數"""
        if provider_name not in self.health_cache:
            return 1.0  # 默認健康
        
        cache = self.health_cache[provider_name]
        total = cache["success_count"] + cache["failure_count"]
        if total == 0:
            return 1.0
        
        success_rate = cache["success_count"] / total
        
        # 如果最近失敗過，降低分數
        if cache["last_failure"]:
            time_since_failure = (datetime.utcnow() - cache["last_failure"]).total_seconds()
            if time_since_failure < 300:  # 5 分鐘內失敗過
                success_rate *= 0.5
        
        return success_rate
```

**驗證標準：**
- ✅ 統一的服務類用於所有場景
- ✅ 實現健康狀態追蹤
- ✅ 實現自動故障轉移
- ✅ 保持向後兼容

**負責人：** 後端開發人員  
**交付物：** 統一的圖片服務管理器

---

#### 任務 2.1.3：更新所有使用點
**目標：** 更新所有使用舊服務類的地方

**需要更新的文件：**
1. `backend/app/api/v1/images.py` - API 端點
2. `backend/app/services/automation/workflow.py` - 工作流
3. `backend/app/services/images/enhanced_photo_matcher.py` - 圖片匹配器
4. 其他使用圖片服務的地方

**驗證標準：**
- ✅ 所有使用點都更新為統一的服務類
- ✅ 沒有遺漏的舊代碼
- ✅ 所有功能正常運作

**負責人：** 後端開發人員  
**交付物：** 更新的代碼和測試報告

---

### 2.2 建立專用 Google Image CSE（第2週）

#### 任務 2.2.1：建立圖片專用的 Custom Search Engine
**目標：** 建立專門用於圖片搜尋的 CSE，提高穩定性

**執行步驟：**
1. 前往 Google Custom Search Console
2. 建立新的搜尋引擎
3. 設定為「搜尋整個網路」
4. 啟用「圖片搜尋」
5. 取得新的 Search Engine ID
6. 更新 Railway 環境變數

**驗證標準：**
- ✅ 新的 CSE 專門用於圖片搜尋
- ✅ 測試確認返回圖片結果
- ✅ 更新環境變數配置

**負責人：** DevOps 工程師  
**交付物：** 新的 Search Engine ID 和配置文檔

---

#### 任務 2.2.2：實現 CSE 配置驗證
**目標：** 在應用啟動時驗證 CSE 配置是否正確

**實施內容：**
```python
# backend/app/utils/cse_validator.py
async def validate_google_cse_config():
    """驗證 Google Custom Search Engine 配置"""
    api_key = getattr(settings, 'GOOGLE_API_KEY', '')
    search_engine_id = getattr(settings, 'GOOGLE_SEARCH_ENGINE_ID', '')
    
    if not api_key or not search_engine_id:
        return {
            "valid": False,
            "message": "GOOGLE_API_KEY 或 GOOGLE_SEARCH_ENGINE_ID 未設定"
        }
    
    # 嘗試一個簡單的搜尋請求
    try:
        from app.services.images.google_custom_search import GoogleCustomSearchService
        service = GoogleCustomSearchService()
        results = await service.search_images("test", limit=1, trace_id="config_validation")
        
        return {
            "valid": True,
            "message": "Google Custom Search Engine 配置正確",
            "test_results": len(results)
        }
    except Exception as e:
        return {
            "valid": False,
            "message": f"Google Custom Search Engine 配置驗證失敗: {str(e)}"
        }
```

**驗證標準：**
- ✅ 應用啟動時驗證 CSE 配置
- ✅ 驗證失敗時記錄詳細錯誤
- ✅ 提供配置建議

**負責人：** 後端開發人員  
**交付物：** CSE 配置驗證模組

---

### 2.3 實現健康檢查與自動降級（第3週）

#### 任務 2.3.1：實現服務健康檢查機制
**目標：** 定期檢查服務健康狀態，自動降級不健康的服務

**實施內容：**
```python
# backend/app/services/images/health_checker.py
class ImageServiceHealthChecker:
    """圖片服務健康檢查器"""
    
    def __init__(self, image_service: ImageService):
        self.image_service = image_service
        self.check_interval = 300  # 5 分鐘檢查一次
    
    async def start_monitoring(self):
        """啟動健康監控"""
        while True:
            await self._check_all_services()
            await asyncio.sleep(self.check_interval)
    
    async def _check_all_services(self):
        """檢查所有服務的健康狀態"""
        test_query = "test"
        for provider in self.image_service.providers:
            try:
                if await provider.is_available():
                    # 嘗試一個簡單的搜尋
                    results = await provider.search_images(
                        test_query,
                        limit=1,
                        trace_id="health_check"
                    )
                    # 更新健康狀態
                    self.image_service._update_health(
                        provider.name,
                        len(results) > 0
                    )
            except Exception as e:
                logger.warning(f"健康檢查失敗 {provider.name}: {e}")
                self.image_service._update_health(provider.name, False)
```

**驗證標準：**
- ✅ 定期檢查服務健康狀態
- ✅ 自動降級不健康的服務
- ✅ 記錄健康檢查結果

**負責人：** 後端開發人員  
**交付物：** 健康檢查模組

---

#### 任務 2.3.2：實現自動故障轉移
**目標：** 當主要服務失敗時，自動切換到備援服務

**實施內容：**
- 已在統一的圖片服務管理器中實現
- 根據健康狀態自動選擇最佳服務
- 實現優先級和健康分數的組合排序

**驗證標準：**
- ✅ 自動故障轉移正常工作
- ✅ 優先使用健康的服務
- ✅ 記錄故障轉移事件

**負責人：** 後端開發人員  
**交付物：** 故障轉移機制文檔

---

## 階段 3：長期優化與監控（第4-6週）

### 3.1 監控與指標（第4週）

#### 任務 3.1.1：實現服務使用指標追蹤
**目標：** 追蹤每個服務的使用情況和性能指標

**實施內容：**
```python
# backend/app/services/images/metrics.py
class ImageServiceMetrics:
    """圖片服務指標追蹤"""
    
    def __init__(self):
        self.metrics = {
            "requests": {},      # 請求次數
            "success": {},       # 成功次數
            "failures": {},      # 失敗次數
            "latency": {},       # 延遲時間
            "error_codes": {},   # 錯誤碼分布
        }
    
    def record_request(self, provider_name: str):
        """記錄請求"""
        if provider_name not in self.metrics["requests"]:
            self.metrics["requests"][provider_name] = 0
        self.metrics["requests"][provider_name] += 1
    
    def record_success(self, provider_name: str, latency: float):
        """記錄成功"""
        # ...
    
    def record_failure(self, provider_name: str, error_code: str, latency: float):
        """記錄失敗"""
        # ...
    
    def get_metrics(self) -> Dict:
        """獲取指標"""
        return self.metrics
```

**驗證標準：**
- ✅ 追蹤所有關鍵指標
- ✅ 提供指標查詢 API
- ✅ 指標數據持久化

**負責人：** 後端開發人員  
**交付物：** 指標追蹤模組和 API

---

#### 任務 3.1.2：實現告警機制
**目標：** 當服務出現問題時自動告警

**實施內容：**
- 當服務連續失敗超過閾值時發送告警
- 當 API 配額用盡時發送告警
- 當所有服務都不可用時發送緊急告警

**驗證標準：**
- ✅ 告警機制正常工作
- ✅ 告警訊息包含足夠資訊
- ✅ 告警不會過於頻繁

**負責人：** DevOps 工程師  
**交付物：** 告警配置和測試報告

---

### 3.2 性能優化（第5週）

#### 任務 3.2.1：實現結果快取
**目標：** 快取常見查詢的結果，減少 API 調用

**實施內容：**
```python
# backend/app/services/images/cache.py
class ImageSearchCache:
    """圖片搜尋結果快取"""
    
    def __init__(self, ttl: int = 3600):  # 1 小時
        self.cache = {}
        self.ttl = ttl
    
    async def get(self, key: str) -> Optional[List[Dict]]:
        """獲取快取結果"""
        if key in self.cache:
            entry = self.cache[key]
            if time.time() - entry["timestamp"] < self.ttl:
                return entry["data"]
            else:
                del self.cache[key]
        return None
    
    async def set(self, key: str, data: List[Dict]):
        """設置快取"""
        self.cache[key] = {
            "data": data,
            "timestamp": time.time()
        }
```

**驗證標準：**
- ✅ 快取機制正常工作
- ✅ 減少 API 調用次數
- ✅ 快取失效機制正確

**負責人：** 後端開發人員  
**交付物：** 快取模組和性能測試報告

---

#### 任務 3.2.2：實現並發請求優化
**目標：** 同時請求多個服務，選擇最快返回的結果

**實施內容：**
- 使用 `asyncio.gather()` 並發請求多個服務
- 選擇最快返回有效結果的服務
- 取消其他未完成的請求

**驗證標準：**
- ✅ 並發請求正常工作
- ✅ 減少總體響應時間
- ✅ 正確處理取消請求

**負責人：** 後端開發人員  
**交付物：** 並發請求實現和性能測試報告

---

### 3.3 文檔與測試（第6週）

#### 任務 3.3.1：完善 API 文檔
**目標：** 提供完整的 API 文檔

**實施內容：**
- 更新 OpenAPI/Swagger 文檔
- 添加請求/響應範例
- 添加錯誤碼說明
- 添加最佳實踐指南

**驗證標準：**
- ✅ API 文檔完整準確
- ✅ 包含所有端點和參數
- ✅ 包含錯誤處理說明

**負責人：** 技術文檔工程師  
**交付物：** 完整的 API 文檔

---

#### 任務 3.3.2：完善單元測試和整合測試
**目標：** 確保代碼質量和穩定性

**實施內容：**
- 為所有圖片服務添加單元測試
- 添加整合測試
- 添加端到端測試
- 實現測試覆蓋率目標（>80%）

**驗證標準：**
- ✅ 所有測試通過
- ✅ 測試覆蓋率達標
- ✅ 測試包含邊界情況

**負責人：** QA 測試人員  
**交付物：** 測試套件和測試報告

---

## 階段 4：持續監控與維護（長期）

### 4.1 定期審查（每月）

#### 任務 4.1.1：服務健康狀況審查
**目標：** 定期審查服務健康狀況和性能指標

**審查內容：**
- 服務成功率
- 平均響應時間
- 錯誤分布
- API 配額使用情況

**負責人：** DevOps 工程師  
**頻率：** 每月

---

#### 任務 4.1.2：代碼質量審查
**目標：** 確保代碼質量和最佳實踐

**審查內容：**
- 代碼審查
- 技術債務評估
- 性能優化機會

**負責人：** 技術負責人  
**頻率：** 每季度

---

### 4.2 持續改進（持續）

#### 任務 4.2.1：添加新的圖片服務
**目標：** 根據需求添加新的圖片服務

**流程：**
1. 評估新服務的需求和可行性
2. 實現統一的服務介面
3. 添加配置和文檔
4. 測試和部署

**負責人：** 後端開發人員  
**觸發條件：** 業務需求

---

#### 任務 4.2.2：優化現有服務
**目標：** 持續優化現有服務的性能和穩定性

**優化方向：**
- 減少 API 調用次數
- 提高響應速度
- 改善錯誤處理
- 優化資源使用

**負責人：** 後端開發人員  
**頻率：** 持續

---

## 風險管理

### 風險 1：Google API 配額限制
**影響：** 高  
**概率：** 中  
**緩解措施：**
- 實現配額監控和告警
- 實現自動切換到備援服務
- 考慮升級付費方案

### 風險 2：服務類統一導致現有功能破壞
**影響：** 高  
**概率：** 低  
**緩解措施：**
- 充分的測試覆蓋
- 漸進式遷移
- 保持向後兼容

### 風險 3：新架構複雜度增加
**影響：** 中  
**概率：** 中  
**緩解措施：**
- 清晰的文檔
- 代碼審查
- 培訓團隊成員

---

## 成功標準

### 階段 1 成功標準
- ✅ 圖片搜尋功能正常工作
- ✅ 所有服務調用都有日誌記錄
- ✅ 前端正確顯示所有來源選項
- ✅ 錯誤訊息詳細且有用

### 階段 2 成功標準
- ✅ 統一的服務類架構
- ✅ 健康檢查機制正常工作
- ✅ 自動故障轉移正常工作
- ✅ 專用 Google Image CSE 建立並配置

### 階段 3 成功標準
- ✅ 監控和指標系統正常運作
- ✅ 性能優化達到目標
- ✅ 文檔完整準確
- ✅ 測試覆蓋率達標

### 階段 4 成功標準
- ✅ 系統穩定運行
- ✅ 定期審查機制建立
- ✅ 持續改進流程建立

---

## 時間表

| 階段 | 時間 | 主要任務 |
|------|------|----------|
| 階段 1 | 第1週 | 緊急診斷與修復 |
| 階段 2 | 第2-3週 | 架構統一與優化 |
| 階段 3 | 第4-6週 | 長期優化與監控 |
| 階段 4 | 持續 | 監控與維護 |

---

## 資源需求

### 人力資源
- 後端開發人員：2人，全職 6週
- 前端開發人員：1人，全職 1週
- DevOps 工程師：1人，兼職 2週
- QA 測試人員：1人，全職 2週
- 技術文檔工程師：1人，兼職 1週

### 技術資源
- Google Custom Search API（可能需要升級付費方案）
- 監控工具（可選）
- 測試環境

---

## 結論

本行動計劃旨在徹底解決圖片搜尋功能問題，並建立一個穩定、可擴展、可維護的長期架構。計劃分為四個階段，從緊急修復到長期優化，確保問題得到徹底解決，並且不會再次發生。

**關鍵成功因素：**
1. 徹底的診斷和測試
2. 統一的架構設計
3. 完善的錯誤處理和日誌記錄
4. 持續的監控和維護

**預期成果：**
- 圖片搜尋功能穩定可靠
- 系統架構清晰統一
- 問題診斷快速準確
- 用戶體驗良好

---

**計劃審查請求：**

請第三方專家審查本行動計劃，重點關注：

1. **計劃完整性**
   - 是否涵蓋所有發現的問題？
   - 是否有遺漏的重要步驟？

2. **技術方案合理性**
   - 架構設計是否合理？
   - 實施方案是否可行？

3. **時間安排**
   - 時間表是否合理？
   - 是否有過於樂觀或保守的地方？

4. **風險管理**
   - 風險識別是否完整？
   - 緩解措施是否有效？

5. **成功標準**
   - 成功標準是否明確可測量？
   - 是否足夠嚴格？

6. **改進建議**
   - 是否有更好的實施方案？
   - 是否有需要補充的內容？

---

**報告結束**

*本行動計劃將根據第三方專家的審查意見進行調整和完善。*

